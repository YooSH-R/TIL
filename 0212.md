# 스택

- ## 스택 응용
  - 부분집합(Subset)
    - 멱집합(Powerset): 특정 집합의 부분집합을 원소로 가지는 집합 ex) { {}, {1}, {2}, {1, 2} } 
    - Backtracing을 이용하여 부분집합 구하기
  
```python
# 재귀함수를 만든다.
def powerset(arr, k, selected):     # arr 집합, k 현재 넣을지 말지 결정할 단계의 원소, selected 현재까지 만들어진 부분집합
    
    # TODO 만약 만들고 있는 부분집합이 조건을 만족하지 못할 경우 돌아가는 코드가 삽입되는 곳(Backtracking)
    pass
    
    # 마지막 원소까지 추가여부를 결정했다면
    if k == len(arr):
        # 출력하고 종료
        print(selected)
        return
        
    # k번째 원소를 selected에 추가하지 않음 -> k번째는 추가하지 않겠다
    powerset(arr, k + 1, selected)
    # k번째 원소를 selected에 추가하고 다음 함수 호출 -> k번째는 추가하겠다
    selected.append(arr[k])
    powerset(arr, k + 1, selected)
    # 다 돌았으면 추가한 원소를 제거
    selected.pop()
``` 
    
  - 순열1
    - Backtracking을 이용하여 순열 구하기
```python
def permutation(arr, r, selected):   # arr 순열을 만들 대상 데이터, r 몇개를 고르고 싶은지, selected 여태까지 고른 원소들
    # TODO 만약 만들고 있는 순열이조건을 만족하지 못할 경우 돌아가는 코드가 삽입되는 곳
  
    # 만약 선택한 애들이 r개가 되면 출력하고 종료
    if len(selected) == r:
        print(selected)
        return
    
    # arr의 원소들을 하나씩 살펴보며
    for item in arr:      
      # 아직 선택하지 않은 경우
      if item not in selected:
        # 선택을 하고 다음 차례에 올 원소를 결정하러 간다.
        selected.append(item)
        permutation(arr, r, selected)
        # 이번에 선택했던 숫자를 뺀다
        selected.pop()
```
  - 조합
    - n개의 원소 중 r개를 고르는 경우의 수
```python
def combination(arr, r, now, selected):     # arr: 조합을 만들고 싶은 데이터, r 몇개를 고르고 싶은지, now 지금 고려하고 있는 원소, selected 선택된 원소들
    # 충분한 원소를 골랐을 경우
    if len(selected) == r:
        print(selected)
        return
    
    # 더이상 고를 원소가 없을 경우
    if now == len(arr):
        # 더이상 만들 수 없다
        return
    
    # now부터 끝까지의 원소들을 고려한다.
    for idx in range(now, len(arr)):
        # idx 원소를 조합에 포함시키기로 결정을 하고
        selected.append(arr[idx])
        # 다음 원소를 고르러 간다.
        combination(arr, r, idx + 1, selected)
        # 이번에 추가한 원소를 제거한다.
        selected.pop()
```  
    
  - 가지치기(Pruning)
    
  - 순열2
    - 자리 교환으로 순열 생성
    
  - 분할정복
    